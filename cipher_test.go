package scheme

import (
	"math/big"
	"testing"

	"github.com/Algemetric/HERatio/Implementation/Golang/oracle"
	"github.com/Algemetric/HERatio/Implementation/Golang/params"
	"github.com/Algemetric/HERatio/Implementation/Golang/sim2d"
)

func TestBFVEnc(t *testing.T) {
	// Create parameters.
	p, err := params.New(params.PLBFV32)
	if err != nil {
		t.Error(err)
	}
	// SIM2D codec.
	sc, err := sim2d.New(p)
	// Pseudo-random params.
	ri := [][]int64{{0, 0, 1, -1, 1, -1, 0, 0, -1, -1, 0, -1, 0, -1, 1, 1, -1, -1, 0, 1, 0, 1, -1, 0, 1, 0, -1, 0, -1, 0, 0, 0}}
	nd := [][]int64{{-1, -2, -4, 1, 0, -6, -2, 7, 1, 5, -4, -1, -2, 1, 4, 2, 0, -1, 5, -2, -7, -5, -3, 2, 0, 2, -2, -2, 1, 4, 0, -3},
		{-7, -1, 4, -4, 3, 0, 0, 3, 2, 3, 2, -1, -1, -3, -2, -3, -3, -1, 4, -3, 4, 0, 0, 1, -2, -3, 0, -3, 1, 4, 3, -4}}
	// Oracle.
	o := oracle.NewOracleDouble(ri, nd)
	// Keychain.
	kc := new(Keychain)
	kc.Params = p
	kc.O = o
	// Public key.
	pkp := [][]int64{{-4037345782, -3864796145, -3246898655, 1681759148, 1408805785, -1107088456, -939512624, 2391561031, 2018740801, -4359243559, -1210139052, 1799894561, 628280240, 1846844091, -4350890031, 1553927765, -4216387062, 1836069870, 2001516332, -3340617435, -1836444418, -2329243899, -3398349649, -2389753653, -538912143, 912064575, 3963899010, -4548007382, 4387623168, 560753881, 3678115029, -4662116232},
		{3047662976, 3648351800, -4723214805, -589412704, -2752366317, -4396812798, -3822959355, -4533739225, 1223700754, -4723897659, -3480506128, 3340699993, 1866454384, -2874149000, -1957459557, 1008485621, 2463063424, 1841973385, 2063260407, -586617775, -3878219761, 3602308653, 3609153671, -716226391, -1465250363, -2004232445, -4336824147, 2790860168, -3274517433, -2236599955, -836182508, -1477538473}}
	pkpb := make([][]*big.Int, len(pkp))
	for i := 0; i < len(pkp); i++ {
		pkpb[i] = make([]*big.Int, len(pkp[i]))
		for j := 0; j < len(pkp[i]); j++ {
			pkpb[i][j] = big.NewInt(pkp[i][j])
		}
	}
	kc.PK = pkpb
	// Cipher.
	cip, err := NewCipher(kc)
	if err != nil {
		t.Error(err)
	}
	// SIM2D encode message 0 (12345.678).
	m0pb := sc.Enc(params.M0)
	// Encrypted message 0 coded.
	ecm0, err := cip.Enc(m0pb)
	if err != nil {
		t.Error(err)
	}
	// Check ciphertext 0.
	c0p := [][]int64{{-3946857853, -2345757187, -3109794709, 3597287897, 3028009461, 4583068216, -793865802, -2493685872, -4356875925, 1446151915, 155195555, -836686371, 2066582773, 4556910428, -2021827196, 4761980565, 2917531420, -2913214043, 3106945542, -1805764275, 2186795682, 2186917851, -35413790, -3547097327, -2678934769, 370357284, -3991359467, -2430971626, -454123784, 3426324942, -4362094484, -690920067},
		{3195929502, -2081665433, -178354177, -2509028365, -983465806, -1897902712, -1876620253, 2041701261, -4906960634, 642398707, -610816364, 3631039276, 2786954504, -636686207, -1293593148, 2004632060, -1556256737, -1792426624, 4406608444, -616705209, 2610504892, -1343850320, 1290341989, 3158043352, -3566746461, -3750192113, -4155437198, -1755722382, 1735554956, -2781807849, 2360617240, -3849070250}}
	for i := 0; i < len(c0p); i++ {
		for j := 0; j < len(ecm0[i]); j++ {
			if c0pb := big.NewInt(c0p[i][j]); c0pb.Cmp(ecm0[i][j]) != 0 {
				t.Errorf("expected value %s at position [%d][%d] but got %s", c0pb.String(), i, j, ecm0[i][j].String())
				break
			}
		}
	}
}

func TestHERatioEnc(t *testing.T) {
	// Case: encrypt message 0 (12345.678).
	// Parameters.
	p, err := params.New(params.PLHERatio16)
	if err != nil {
		t.Error(err)
	}
	// Pseudo-random params.
	ri := [][]int64{{0, 0, 1, -1, 1, -1, 0, 0, -1, -1, 0, -1, 0, -1, 1, 1, -1, -1, 0, 1, 0, 1, -1, 0, 1, 0, -1, 0, -1, 0, 0, 0}}
	nd := [][]int64{{-1, -2, -4, 1, 0, -6, -2, 7, 1, 5, -4, -1, -2, 1, 4, 2, 0, -1, 5, -2, -7, -5, -3, 2, 0, 2, -2, -2, 1, 4, 0, -3},
		{-7, -1, 4, -4, 3, 0, 0, 3, 2, 3, 2, -1, -1, -3, -2, -3, -3, -1, 4, -3, 4, 0, 0, 1, -2, -3, 0, -3, 1, 4, 3, -4}}
	// Oracle.
	o := oracle.NewOracleDouble(ri, nd)
	// Keychain.
	kc := new(Keychain)
	kc.Params = p
	kc.O = o
	// Public key.
	pkp := [][]int64{{-4216387067, 1836069869, 2001516335, -3340617436, -1836444424, -2329243897, -3398349639, -2389753658, -538912150, 912064576, 3963899003, -4548007374, 4387623173, 560753886, 3678115043, -4662116239, 4037345779, 3864796148, 3246898652, -1681759155, -1408805783, 1107088450, 939512626, -2391561032, -2018740806, 4359243558, 1210139051, -1799894561, -628280241, -1846844096, 4350890023, -1553927766},
		{3047662976, 3648351800, -4723214805, -589412704, -2752366317, -4396812798, -3822959355, -4533739225, 1223700754, -4723897659, -3480506128, 3340699993, 1866454384, -2874149000, -1957459557, 1008485621, 2463063424, 1841973385, 2063260407, -586617775, -3878219761, 3602308653, 3609153671, -716226391, -1465250363, -2004232445, -4336824147, 2790860168, -3274517433, -2236599955, -836182508, -1477538473}}
	pkpb := make([][]*big.Int, len(pkp))
	for i := 0; i < len(pkp); i++ {
		pkpb[i] = make([]*big.Int, len(pkp[i]))
		for j := 0; j < len(pkp[i]); j++ {
			pkpb[i][j] = big.NewInt(pkp[i][j])
		}
	}
	kc.PK = pkpb
	// Cipher.
	cip, err := NewCipher(kc)
	if err != nil {
		t.Error(err)
	}
	// Laurent code for message 0 (12345.678).
	m0 := []int64{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, -2, -3, -4, -5, 4, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
	m0b := make([]*big.Int, len(m0))
	for i := 0; i < len(m0b); i++ {
		m0b[i] = big.NewInt(m0[i])
	}
	// Encrypted message 0.
	c0, err := cip.Enc(m0b)
	if err != nil {
		t.Error(err)
	}
	// Check ciphertext 0.
	c0p := [][]int64{{3928319131, 2322583730, 3128333473, -3588018546, -3023374777, -4583068212, 793865758, 2493685852, 4356875931, -1446151930, -155195535, 836686378, -2066582784, -4566179797, 2012557833, -4775884647, -2936070142, 2890040606, -3088406786, 1815033680, -2182161000, -2186917847, 35413812, 3547097307, 2678934739, -370357249, 3991359443, 2430971629, 454123781, -3417055595, 4371363907, 704824141},
		{-1556256741, -1792426624, 4406608444, -616705210, 2610504891, -1343850320, 1290341989, 3158043354, -3566746457, -3750192107, -4155437196, -1755722380, 1735554954, -2781807856, 2360617235, -3849070249, -3195929512, 2081665431, 178354185, 2509028358, 983465813, 1897902712, 1876620253, -2041701257, 4906960634, -642398707, 610816366, -3631039280, -2786954504, 636686208, 1293593149, -2004632067}}
	for i := 0; i < len(c0p); i++ {
		for j := 0; j < len(c0p[i]); j++ {
			if c0pb := big.NewInt(c0p[i][j]); c0pb.Cmp(c0[i][j]) != 0 {
				t.Errorf("expected value %s at position [%d][%d] but got %s", c0pb.String(), i, j, c0[i][j].String())
				break
			}
		}
	}

	// Case: encrypt message 1 (947.1273).
	// Pseudo-random params.
	ri = [][]int64{{1, 0, 0, -1, 1, -1, 0, 1, 0, 1, 0, -1, 0, 1, -1, -1, 0, 1, 0, 1, 0, 0, 1, 0, -1, 1, 1, 1, 1, 1, -1, 1}}
	nd = [][]int64{{2, -2, -1, -5, 1, 2, 3, -1, 7, -5, 0, 6, 1, -2, 3, -2, -6, -5, 4, -3, 6, 2, -2, 3, -5, 2, 4, 2, -1, -1, 0, 4},
		{-1, 4, 5, -1, -5, -1, 2, 1, -1, -2, 1, 3, 1, -4, 1, 1, 3, 2, 0, 2, -1, 1, 0, 3, 5, 6, -3, -2, 1, 4, 0, -1}}
	// Oracle.
	o = oracle.NewOracleDouble(ri, nd)
	// Keychain.
	kc.O = o
	// Laurent code for message 1 (947.1273).
	m1 := []int64{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, -3, 3, 1, -3, -5, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
	m1b := make([]*big.Int, len(m1))
	for i := 0; i < len(m1b); i++ {
		m1b[i] = big.NewInt(m1[i])
	}
	// Cipher.
	cip, err = NewCipher(kc)
	if err != nil {
		t.Error(err)
	}
	// Encrypted message 1 coded.
	c1, err := cip.Enc(m1b)
	if err != nil {
		t.Error(err)
	}
	// Check ciphertext 1.
	c1p := [][]int64{{-801430505, -878485248, -3619214677, 3724339951, -4146097963, 2457285451, -166152169, 1146493397, -3930539301, -2148721601, 3525944698, 3336814609, 646191097, 1442584217, -1000306916, -1968228144, -3893801664, 4707109067, -4599778255, -1375893388, -3059390189, 7375620, 394482092, -1019907702, 1835725930, 3895685774, 4087024810, 1664162097, 4717028837, 4336772799, -4821294640, -1500042157},
		{4264193866, -1527646385, 1813200464, -3602499427, 1093465074, -258723476, 3334380716, 2120724897, 4787031003, 1767301708, -3677492885, 3839699240, -3074468330, -1120360217, 889645300, -4461608467, -2355083155, 3243450666, 1401312351, -4770263490, -1978232958, -4054237786, 1084734439, -422038801, -4464537862, -3270933427, -1790685853, 2585691139, 2152982520, 3343571564, 464216747, -4541369780}}
	for i := 0; i < len(c1p); i++ {
		for j := 0; j < len(c1p[i]); j++ {
			if c1pb := big.NewInt(c1p[i][j]); c1pb.Cmp(c1[i][j]) != 0 {
				t.Errorf("expected value %s at position [%d][%d] but got %s", c1pb.String(), i, j, c1[i][j].String())
				break
			}
		}
	}
}

func TestBFVDec(t *testing.T) {
	// Create parameters.
	p, err := params.New(params.PLBFV32)
	if err != nil {
		t.Error(err)
	}
	// SIM2D codec.
	sc, err := sim2d.New(p)
	// Keychain.
	kc := new(Keychain)
	kc.Params = p
	// Secret key.
	sk := []int64{1, 0, 0, 0, -1, 1, -1, 0, -1, 1, 1, -1, -1, 1, 0, -1, 1, 1, 1, 0, 0, 1, 0, -1, 0, -1, 1, 0, 0, -1, 1, 0}
	skb := make([]*big.Int, len(sk))
	for i := 0; i < len(skb); i++ {
		skb[i] = big.NewInt(sk[i])
	}
	kc.SK = skb
	// Cipher.
	cip, err := NewCipher(kc)
	if err != nil {
		t.Error(err)
	}
	// Check ciphertext 0.
	c0p := [][]int64{{-3946857853, -2345757187, -3109794709, 3597287897, 3028009461, 4583068216, -793865802, -2493685872, -4356875925, 1446151915, 155195555, -836686371, 2066582773, 4556910428, -2021827196, 4761980565, 2917531420, -2913214043, 3106945542, -1805764275, 2186795682, 2186917851, -35413790, -3547097327, -2678934769, 370357284, -3991359467, -2430971626, -454123784, 3426324942, -4362094484, -690920067},
		{3195929502, -2081665433, -178354177, -2509028365, -983465806, -1897902712, -1876620253, 2041701261, -4906960634, 642398707, -610816364, 3631039276, 2786954504, -636686207, -1293593148, 2004632060, -1556256737, -1792426624, 4406608444, -616705209, 2610504892, -1343850320, 1290341989, 3158043352, -3566746461, -3750192113, -4155437198, -1755722382, 1735554956, -2781807849, 2360617240, -3849070250}}
	ecm0 := make([][]*big.Int, len(c0p))
	for i := 0; i < len(c0p); i++ {
		ecm0[i] = make([]*big.Int, len(c0p[i]))
		for j := 0; j < len(c0p[i]); j++ {
			ecm0[i][j] = big.NewInt(c0p[i][j])
		}
	}
	// Decrypted message 0.
	cm0, err := cip.Dec(ecm0)
	if err != nil {
		t.Error(err)
	}
	// SIM2D message 0 decoded.
	m0, err := sc.Dec(cm0)
	if err != nil {
		t.Error(err)
	}
	// Check message 0 decrypted and decoded.
	em0 := 12345.678
	if m0 != em0 {
		t.Errorf("expected %f but got %f", em0, m0)
	}
}

func TestHERatioDec(t *testing.T) {
	// Case: decrypt message 0 (12345.678).
	// Parameters.
	p, err := params.New(params.PLHERatio16)
	if err != nil {
		t.Error(err)
	}
	// Keychain.
	kc := new(Keychain)
	kc.Params = p
	// Secret key preset big.
	skp := []int64{1, 0, 0, 0, -1, 1, -1, 0, -1, 1, 1, -1, -1, 1, 0, -1, 1, 1, 1, 0, 0, 1, 0, -1, 0, -1, 1, 0, 0, -1, 1, 0}
	skpb := make([]*big.Int, len(skp))
	for i := 0; i < len(skp); i++ {
		skpb[i] = big.NewInt(skp[i])
	}
	kc.SK = skpb
	// Cipher.
	cip, err := NewCipher(kc)
	if err != nil {
		t.Error(err)
	}
	// Ciphertext 0.
	c0p := [][]int64{{3928319131, 2322583730, 3128333473, -3588018546, -3023374777, -4583068212, 793865758, 2493685852, 4356875931, -1446151930, -155195535, 836686378, -2066582784, -4566179797, 2012557833, -4775884647, -2936070142, 2890040606, -3088406786, 1815033680, -2182161000, -2186917847, 35413812, 3547097307, 2678934739, -370357249, 3991359443, 2430971629, 454123781, -3417055595, 4371363907, 704824141},
		{-1556256741, -1792426624, 4406608444, -616705210, 2610504891, -1343850320, 1290341989, 3158043354, -3566746457, -3750192107, -4155437196, -1755722380, 1735554954, -2781807856, 2360617235, -3849070249, -3195929512, 2081665431, 178354185, 2509028358, 983465813, 1897902712, 1876620253, -2041701257, 4906960634, -642398707, 610816366, -3631039280, -2786954504, 636686208, 1293593149, -2004632067}}
	c0pb := make([][]*big.Int, len(c0p))
	for i := 0; i < len(c0p); i++ {
		c0pb[i] = make([]*big.Int, len(c0p[i]))
		for j := 0; j < len(c0p[i]); j++ {
			c0pb[i][j] = big.NewInt(c0p[i][j])
		}
	}
	// Decrypted message 0.
	cm0, err := cip.Dec(c0pb)
	if err != nil {
		t.Error(err)
	}
	// Check message 0 decrypted.
	m0 := []int64{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, -2, -3, -4, -5, 4, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
	for i := 0; i < len(m0); i++ {
		if m0[i] != cm0[i].Int64() {
			t.Errorf("expected %d but got %d", m0[i], cm0[i])
		}
	}

	// Case: decrypt message 1 (947.1273).
	// Ciphertext 1.
	c1p := [][]int64{{-801430505, -878485248, -3619214677, 3724339951, -4146097963, 2457285451, -166152169, 1146493397, -3930539301, -2148721601, 3525944698, 3336814609, 646191097, 1442584217, -1000306916, -1968228144, -3893801664, 4707109067, -4599778255, -1375893388, -3059390189, 7375620, 394482092, -1019907702, 1835725930, 3895685774, 4087024810, 1664162097, 4717028837, 4336772799, -4821294640, -1500042157},
		{4264193866, -1527646385, 1813200464, -3602499427, 1093465074, -258723476, 3334380716, 2120724897, 4787031003, 1767301708, -3677492885, 3839699240, -3074468330, -1120360217, 889645300, -4461608467, -2355083155, 3243450666, 1401312351, -4770263490, -1978232958, -4054237786, 1084734439, -422038801, -4464537862, -3270933427, -1790685853, 2585691139, 2152982520, 3343571564, 464216747, -4541369780}}
	c1pb := make([][]*big.Int, len(c1p))
	for i := 0; i < len(c1p); i++ {
		c1pb[i] = make([]*big.Int, len(c1p[i]))
		for j := 0; j < len(c1p[i]); j++ {
			c1pb[i][j] = big.NewInt(c1p[i][j])
		}
	}
	// Decrypted message 1.
	cm1, err := cip.Dec(c1pb)
	if err != nil {
		t.Error(err)
	}
	// Check message 1 decrypted.
	m1 := []int64{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, -3, 3, 1, -3, -5, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
	for i := 0; i < len(m1); i++ {
		if m1[i] != cm1[i].Int64() {
			t.Errorf("expected %d but got %d", m1[i], cm1[i])
		}
	}
}
